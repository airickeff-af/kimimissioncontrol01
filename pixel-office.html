<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üéÆ Pixel Office v2 | Living Command Center</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: #1a1a2e;
            --panel-border: #e94560;
            --panel-shadow: #533483;
            --text-light: #eaeaea;
            --text-secondary: #888;
            --accent-cyan: #00d4ff;
            --accent-green: #22c55e;
            --accent-yellow: #fbbf24;
            --accent-pink: #ff6b9d;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; image-rendering: pixelated; }
        
        body {
            font-family: 'VT323', monospace;
            background: var(--bg-primary);
            color: var(--text-light);
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                linear-gradient(rgba(0, 212, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.02) 1px, transparent 1px);
            background-size: 32px 32px;
            pointer-events: none;
            z-index: 0;
        }
        
        .header {
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--accent-cyan);
            padding: 0 1rem;
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0; left: 0; right: 0;
            z-index: 1000;
        }
        
        .brand { display: flex; align-items: center; gap: 0.5rem; }
        
        .logo {
            width: 32px; height: 32px;
            background: var(--accent-cyan);
            border: 2px solid var(--text-light);
            display: flex; align-items: center; justify-content: center;
            font-size: 1rem;
        }
        
        .brand-text h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.55rem;
            line-height: 1.3;
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.7rem;
        }
        
        .status-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #officeCanvas {
            position: fixed;
            top: 50px; left: 0; right: 0; bottom: 0;
            width: 100%; height: calc(100% - 50px);
            background: linear-gradient(135deg, #1a1a2e 0%, #0a0a0f 100%);
            cursor: grab;
        }
        
        #officeCanvas:active { cursor: grabbing; }
        
        .controls {
            position: fixed;
            bottom: 20px; left: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        
        .btn {
            padding: 10px 16px;
            background: var(--bg-card);
            border: 2px solid var(--accent-cyan);
            border-radius: 4px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: var(--text-light);
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .btn:hover { 
            background: var(--accent-cyan);
            color: #000;
        }
        
        .stats-overlay {
            position: fixed;
            top: 60px; right: 20px;
            background: rgba(10, 10, 15, 0.9);
            border: 2px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 12px 16px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            z-index: 100;
            min-width: 140px;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        
        .stat-row:last-child { margin-bottom: 0; }
        
        /* Tooltip */
        .agent-tooltip {
            position: fixed;
            background: rgba(10, 10, 15, 0.95);
            border: 2px solid var(--accent-cyan);
            border-radius: 8px;
            padding: 12px;
            pointer-events: none;
            z-index: 1001;
            display: none;
            min-width: 180px;
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3);
        }
        
        .tooltip-name {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.55rem;
            color: var(--accent-cyan);
            margin-bottom: 6px;
        }
        
        .tooltip-role {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        
        .tooltip-task {
            font-size: 0.8rem;
            color: var(--text-light);
            margin-bottom: 6px;
        }
        
        .tooltip-status {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.5rem;
            font-family: 'Press Start 2P', cursive;
        }
        
        .status-idle { background: #666; }
        .status-working { background: var(--accent-green); color: #000; }
        .status-walking { background: var(--accent-yellow); color: #000; }
        
        .loading-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }
        
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-text {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: var(--accent-cyan);
            margin-bottom: 20px;
        }
        
        .loading-bar {
            width: 300px;
            height: 20px;
            background: var(--bg-card);
            border: 2px solid var(--accent-cyan);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .loading-fill {
            height: 100%;
            background: var(--accent-cyan);
            width: 0%;
            transition: width 0.3s;
        }
        
        @media (max-width: 768px) {
            .controls { bottom: 10px; left: 10px; }
            .btn { padding: 8px 12px; font-size: 0.45rem; }
            .stats-overlay { top: 60px; right: 10px; font-size: 0.45rem; }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="brand">
            <div class="logo">üéÆ</div>
            <div class="brand-text">
                <h1>PIXEL OFFICE</h1>
            </div>
        </div>
        <div class="connection-status">
            <span class="status-dot"></span>
            <span>LIVE</span>
        </div>
    </header>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-text">üéÆ LOADING SPRITES...</div>
        <div class="loading-bar"><div class="loading-fill" id="loadingFill"></div></div>
        <div style="margin-top:10px;font-size:0.6rem;color:var(--text-secondary)" id="loadingText">0/22</div>
    </div>
    
    <canvas id="officeCanvas"></canvas>
    
    <div class="controls">
        <button class="btn" onclick="resetCamera()">üéØ RESET</button>
        <button class="btn" onclick="toggleDebug()">üêõ DEBUG</button>
    </div>
    
    <div class="stats-overlay">
        <div class="stat-row"><span>FPS:</span><span id="fpsCounter">60</span></div>
        <div class="stat-row"><span>AGENTS:</span><span>22</span></div>
        <div class="stat-row"><span>ACTIVE:</span><span id="activeCounter">0</span></div>
    </div>
    
    <div class="agent-tooltip" id="tooltip">
        <div class="tooltip-name" id="tooltipName">Agent</div>
        <div class="tooltip-role" id="tooltipRole">Role</div>
        <div class="tooltip-task" id="tooltipTask">Task</div>
        <span class="tooltip-status" id="tooltipStatus">Idle</span>
    </div>

    <script>
        // ============================================
        // AGENT DATA - All 22 agents with tasks
        // ============================================
        const AGENTS_DATA = [
            { id: 'ericf', name: 'EricF', role: 'Commander', color: '#ffd700', x: -8, y: -6, task: 'Strategic Planning' },
            { id: 'nexus', name: 'Nexus', role: 'Orchestrator', color: '#00d4ff', x: 4, y: -6, task: 'System Coordination' },
            { id: 'codemaster', name: 'CodeMaster', role: 'Backend Lead', color: '#22c55e', x: -7, y: 2, task: 'API Architecture' },
            { id: 'code-1', name: 'Code-1', role: 'Backend', color: '#22c55e', x: -4, y: 2, task: 'Database Optimization' },
            { id: 'code-2', name: 'Code-2', role: 'Backend', color: '#22c55e', x: -7, y: 4.5, task: 'Microservices' },
            { id: 'code-3', name: 'Code-3', role: 'Backend', color: '#22c55e', x: -4, y: 4.5, task: 'Security Patches' },
            { id: 'forge', name: 'Forge', role: 'UI Lead', color: '#f97316', x: 3, y: -3, task: 'Component Library' },
            { id: 'forge-2', name: 'Forge-2', role: 'UI', color: '#f97316', x: 6, y: -3, task: 'Responsive Design' },
            { id: 'forge-3', name: 'Forge-3', role: 'UI', color: '#f97316', x: 3, y: -0.5, task: 'Animation System' },
            { id: 'pixel', name: 'Pixel', role: 'Designer', color: '#a855f7', x: 6, y: -0.5, task: 'Sprite Creation' },
            { id: 'glasses', name: 'Glasses', role: 'Researcher', color: '#3b82f6', x: 3, y: 2, task: 'Market Analysis' },
            { id: 'quill', name: 'Quill', role: 'Writer', color: '#ec4899', x: 6, y: 2, task: 'Documentation' },
            { id: 'gary', name: 'Gary', role: 'Marketing', color: '#f59e0b', x: -2, y: 6, task: 'Campaign Strategy' },
            { id: 'larry', name: 'Larry', role: 'Social', color: '#06b6d4', x: 1, y: 6, task: 'Community Management' },
            { id: 'buzz', name: 'Buzz', role: 'Social', color: '#fbbf24', x: 4, y: 6, task: 'Trend Analysis' },
            { id: 'sentry', name: 'Sentry', role: 'DevOps', color: '#ef4444', x: -5, y: 7, task: 'CI/CD Pipeline' },
            { id: 'audit', name: 'Audit', role: 'QA', color: '#8b5cf6', x: -2, y: 7, task: 'Code Review' },
            { id: 'cipher', name: 'Cipher', role: 'Security', color: '#6366f1', x: 1, y: 7, task: 'Threat Detection' },
            { id: 'dealflow', name: 'DealFlow', role: 'Lead Gen', color: '#10b981', x: 4, y: 7, task: 'Partnership Outreach' },
            { id: 'coldcall', name: 'ColdCall', role: 'Outreach', color: '#f97316', x: -6, y: 6, task: 'Cold Emails' },
            { id: 'scout', name: 'Scout', role: 'Intel', color: '#00d4ff', x: 7, y: 4, task: 'Competitor Research' },
            { id: 'pie', name: 'PIE', role: 'Intelligence', color: '#8b5cf6', x: 7, y: 6, task: 'Data Analytics' },
        ];

        const TASKS = ['Coding', 'Reviewing', 'Testing', 'Deploying', 'Designing', 'Researching', 'Writing', 'Analyzing', 'Meeting', 'Debugging', 'Optimizing', 'Planning'];

        // ============================================
        // SPRITE LOADER
        // ============================================
        class SpriteLoader {
            constructor(basePath = 'pixel-office/assets/sprites/') {
                this.basePath = basePath;
                this.sprites = new Map();
                this.metadata = null;
                this.loaded = false;
                this.failedLoads = [];
            }

            async load() {
                // Load metadata
                try {
                    const response = await fetch(`${this.basePath}sprite_metadata.json`);
                    this.metadata = await response.json();
                } catch (error) {
                    console.warn('Using default metadata');
                    this.metadata = {
                        sprite_size: 16,
                        frames_per_animation: 8,
                        animations: { idle: 0, walk_down: 1, walk_up: 2, walk_left: 3, walk_right: 4, typing: 5, talking: 6 },
                        agents: {}
                    };
                    AGENTS_DATA.forEach((agent, i) => {
                        this.metadata.agents[agent.id] = { name: agent.name, row: i };
                    });
                }

                // Load all agent sprites
                const total = AGENTS_DATA.length;
                let loaded = 0;
                
                const loadPromises = AGENTS_DATA.map(agent => 
                    this.loadAgentSprite(agent.id).then(() => {
                        loaded++;
                        const pct = (loaded / total) * 100;
                        document.getElementById('loadingFill').style.width = pct + '%';
                        document.getElementById('loadingText').textContent = `${loaded}/${total}`;
                    })
                );
                
                await Promise.all(loadPromises);
                this.loaded = true;
                
                // Hide loading overlay
                setTimeout(() => {
                    document.getElementById('loadingOverlay').classList.add('hidden');
                }, 500);
            }

            loadAgentSprite(agentId) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const agentMeta = this.metadata.agents[agentId] || { row: 0 };
                        this.sprites.set(agentId, { image: img, row: agentMeta.row });
                        resolve();
                    };
                    img.onerror = () => {
                        this.failedLoads.push(agentId);
                        // Create fallback
                        const canvas = document.createElement('canvas');
                        canvas.width = 128; canvas.height = 16;
                        const ctx = canvas.getContext('2d');
                        const agent = AGENTS_DATA.find(a => a.id === agentId);
                        ctx.fillStyle = agent ? agent.color : '#888';
                        ctx.fillRect(0, 0, 128, 16);
                        ctx.fillStyle = '#000';
                        for (let i = 0; i < 8; i++) {
                            ctx.fillRect(i * 16 + 4, 4, 2, 2);
                            ctx.fillRect(i * 16 + 10, 4, 2, 2);
                            ctx.fillRect(i * 16 + 6, 10, 4, 2);
                        }
                        const fallbackImg = new Image();
                        fallbackImg.src = canvas.toDataURL();
                        fallbackImg.onload = () => {
                            this.sprites.set(agentId, { image: fallbackImg, row: 0 });
                            resolve();
                        };
                    };
                    img.crossOrigin = 'anonymous';
                    img.src = `${this.basePath}${agentId}_sheet.png`;
                });
            }

            getSprite(agentId, animation, frame) {
                const sprite = this.sprites.get(agentId);
                if (!sprite) return null;

                const animIndex = this.metadata.animations[animation] || 0;
                const framesPerAnim = this.metadata.frames_per_animation || 8;
                const spriteSize = this.metadata.sprite_size || 16;
                
                const x = (animIndex * framesPerAnim + (Math.floor(frame) % framesPerAnim)) * spriteSize;
                const y = sprite.row * spriteSize;

                return { image: sprite.image, sx: x, sy: y, sw: spriteSize, sh: spriteSize };
            }
        }

        // ============================================
        // AGENT CLASS
        // ============================================
        class Agent {
            constructor(data) {
                this.id = data.id;
                this.name = data.name;
                this.role = data.role;
                this.color = data.color;
                this.baseX = data.x;
                this.baseY = data.y;
                this.x = data.x;
                this.y = data.y;
                this.targetX = data.x;
                this.targetY = data.y;
                this.baseTask = data.task;
                this.currentTask = data.task;
                
                this.animation = 'idle';
                this.frame = 0;
                this.frameTimer = 0;
                this.frameDuration = 120 + Math.random() * 60;
                
                this.speed = 1.5 + Math.random();
                this.direction = 'down';
                this.activity = 'idle';
                this.idleTimer = 0;
                
                this.scale = 2;
                this.selected = false;
                this.hover = false;
                this.progress = 0;
            }

            update(dt) {
                this.frameTimer += dt;
                if (this.frameTimer >= this.frameDuration) {
                    this.frameTimer = 0;
                    this.frame = (this.frame + 1) % 8;
                }

                if (this.activity === 'idle') {
                    this.idleTimer += dt;
                    this.animation = 'idle';
                    if (this.idleTimer > 4000 + Math.random() * 6000) {
                        this.startWalking();
                    }
                } else if (this.activity === 'walking') {
                    this.updateWalking(dt);
                } else if (this.activity === 'working') {
                    this.animation = 'typing';
                    this.progress = (this.progress + dt * 0.0001) % 1;
                }
            }

            startWalking() {
                const angle = Math.random() * Math.PI * 2;
                const distance = 2 + Math.random() * 4;
                this.targetX = Math.max(-10, Math.min(10, this.baseX + Math.cos(angle) * distance));
                this.targetY = Math.max(-8, Math.min(8, this.baseY + Math.sin(angle) * distance));
                
                this.activity = 'walking';
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    this.direction = dx > 0 ? 'right' : 'left';
                } else {
                    this.direction = dy > 0 ? 'down' : 'up';
                }
            }

            updateWalking(dt) {
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 0.2) {
                    this.x = this.targetX;
                    this.y = this.targetY;
                    this.activity = 'working';
                    this.currentTask = TASKS[Math.floor(Math.random() * TASKS.length)];
                    this.idleTimer = 0;
                } else {
                    const moveDist = this.speed * dt * 0.003;
                    this.x += (dx / dist) * moveDist;
                    this.y += (dy / dist) * moveDist;
                    this.animation = `walk_${this.direction}`;
                }
            }

            getScreenPos(isoMath, camera, canvas) {
                const pos = isoMath.toScreen(this.x, this.y, 0);
                return {
                    x: (pos.x - camera.x) * camera.zoom,
                    y: (pos.y - camera.y) * camera.zoom
                };
            }

            render(ctx, spriteLoader, isoMath, camera, canvas) {
                const screenPos = this.getScreenPos(isoMath, camera, canvas);
                const size = 32 * camera.zoom;
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(screenPos.x, screenPos.y + size * 0.35, size * 0.4, size * 0.12, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Sprite
                const sprite = spriteLoader.getSprite(this.id, this.animation, this.frame);
                if (sprite) {
                    ctx.drawImage(
                        sprite.image,
                        sprite.sx, sprite.sy, sprite.sw, sprite.sh,
                        screenPos.x - size / 2, screenPos.y - size, size, size
                    );
                }
                
                // Selection/hover highlight
                if (this.selected || this.hover) {
                    ctx.strokeStyle = this.selected ? '#00d4ff' : '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenPos.x - size/2 - 2, screenPos.y - size - 2, size + 4, size + 4);
                }
            }

            containsPoint(mx, my, isoMath, camera, canvas) {
                const pos = this.getScreenPos(isoMath, camera, canvas);
                const size = 32 * camera.zoom;
                return mx >= pos.x - size/2 && mx <= pos.x + size/2 &&
                       my >= pos.y - size && my <= pos.y + size * 0.3;
            }
        }

        // ============================================
        // MAIN RENDERER
        // ============================================
        class OfficeRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.agents = new Map();
                this.camera = { x: 0, y: 0, zoom: 1 };
                this.running = false;
                this.debug = false;
                this.hoveredAgent = null;
                
                this.isoMath = {
                    toScreen: (x, y, z) => ({
                        x: (x - y) * 32 + this.canvas.width / 2,
                        y: (x + y) * 16 - z * 16 + this.canvas.height / 3
                    })
                };
                
                this.setupCanvas();
                this.setupInteractions();
            }

            setupCanvas() {
                const resize = () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight - 50;
                };
                resize();
                window.addEventListener('resize', resize);
            }

            setupInteractions() {
                let isDragging = false;
                let dragStartX, dragStartY;
                
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    let clickedAgent = null;
                    for (const agent of this.agents.values()) {
                        if (agent.containsPoint(x, y, this.isoMath, this.camera, this.canvas)) {
                            clickedAgent = agent;
                            break;
                        }
                    }
                    
                    if (clickedAgent) {
                        this.agents.forEach(a => a.selected = false);
                        clickedAgent.selected = true;
                    } else {
                        isDragging = true;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                    }
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    let newHovered = null;
                    for (const agent of this.agents.values()) {
                        agent.hover = false;
                        if (agent.containsPoint(x, y, this.isoMath, this.camera, this.canvas)) {
                            newHovered = agent;
                        }
                    }
                    
                    if (newHovered) newHovered.hover = true;
                    
                    if (newHovered !== this.hoveredAgent) {
                        this.hoveredAgent = newHovered;
                        this.updateTooltip(e.clientX, e.clientY);
                    } else if (this.hoveredAgent) {
                        this.updateTooltip(e.clientX, e.clientY);
                    }
                    
                    if (isDragging) {
                        const dx = e.clientX - dragStartX;
                        const dy = e.clientY - dragStartY;
                        this.camera.x += dx / this.camera.zoom;
                        this.camera.y += dy / this.camera.zoom;
                        dragStartX = e.clientX;
                        dragStartY = e.clientY;
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => isDragging = false);
                this.canvas.addEventListener('mouseleave', () => {
                    this.hoveredAgent = null;
                    this.agents.forEach(a => a.hover = false);
                    document.getElementById('tooltip').style.display = 'none';
                });
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const factor = e.deltaY > 0 ? 0.9 : 1.1;
                    this.camera.zoom = Math.max(0.5, Math.min(3, this.camera.zoom * factor));
                });
                
                // Touch support
                let touchStartDist = 0;
                this.canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        touchStartDist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                    } else if (e.touches.length === 1) {
                        isDragging = true;
                        dragStartX = e.touches[0].clientX;
                        dragStartY = e.touches[0].clientY;
                    }
                });
                
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (e.touches.length === 2) {
                        const dist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        const factor = dist / touchStartDist;
                        this.camera.zoom = Math.max(0.5, Math.min(3, this.camera.zoom * factor));
                        touchStartDist = dist;
                    } else if (e.touches.length === 1 && isDragging) {
                        const dx = e.touches[0].clientX - dragStartX;
                        const dy = e.touches[0].clientY - dragStartY;
                        this.camera.x += dx / this.camera.zoom;
                        this.camera.y += dy / this.camera.zoom;
                        dragStartX = e.touches[0].clientX;
                        dragStartY = e.touches[0].clientY;
                    }
                });
                
                this.canvas.addEventListener('touchend', () => isDragging = false);
            }

            updateTooltip(clientX, clientY) {
                const tooltip = document.getElementById('tooltip');
                if (this.hoveredAgent) {
                    tooltip.style.display = 'block';
                    tooltip.style.left = Math.min(clientX + 15, window.innerWidth - 200) + 'px';
                    tooltip.style.top = Math.min(clientY + 15, window.innerHeight - 120) + 'px';
                    document.getElementById('tooltipName').textContent = this.hoveredAgent.name;
                    document.getElementById('tooltipRole').textContent = this.hoveredAgent.role;
                    document.getElementById('tooltipTask').textContent = this.hoveredAgent.currentTask;
                    const statusEl = document.getElementById('tooltipStatus');
                    statusEl.textContent = this.hoveredAgent.activity;
                    statusEl.className = 'tooltip-status status-' + this.hoveredAgent.activity;
                } else {
                    tooltip.style.display = 'none';
                }
            }

            addAgent(data) {
                const agent = new Agent(data);
                this.agents.set(data.id, agent);
                return agent;
            }

            start() {
                if (this.running) return;
                this.running = true;
                this.lastTime = performance.now();
                this.loop();
            }

            loop() {
                if (!this.running) return;
                const now = performance.now();
                const dt = now - this.lastTime;
                this.lastTime = now;
                this.update(dt);
                this.render();
                requestAnimationFrame(() => this.loop());
            }

            update(dt) {
                for (const agent of this.agents.values()) agent.update(dt);
            }

            render() {
                const ctx = this.ctx;
                const canvas = this.canvas;
                
                ctx.fillStyle = '#0a0a0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                this.drawFloor();
                
                const sortedAgents = Array.from(this.agents.values())
                    .sort((a, b) => (a.y + a.x) - (b.y + b.x));
                
                for (const agent of sortedAgents) {
                    agent.render(ctx, spriteLoader, this.isoMath, this.camera, canvas);
                }
                
                if (this.debug) {
                    ctx.fillStyle = '#0f0';
                    ctx.font = '12px monospace';
                    ctx.fillText(`Camera: ${this.camera.x.toFixed(1)}, ${this.camera.y.toFixed(1)}, zoom: ${this.camera.zoom.toFixed(2)}`, 10, 20);
                    ctx.fillText(`Agents: ${this.agents.size}`, 10, 40);
                    ctx.fillText(`Hovered: ${this.hoveredAgent ? this.hoveredAgent.name : 'none'}`, 10, 60);
                }
            }

            drawFloor() {
                const ctx = this.ctx;
                const size = 15;
                
                for (let x = -size; x <= size; x++) {
                    for (let y = -size; y <= size; y++) {
                        const pos = this.isoMath.toScreen(x, y, 0);
                        const camX = (pos.x - this.camera.x) * this.camera.zoom;
                        const camY = (pos.y - this.camera.y) * this.camera.zoom;
                        
                        const tileW = 32 * this.camera.zoom;
                        const tileH = 16 * this.camera.zoom;
                        
                        ctx.fillStyle = (x + y) % 2 === 0 ? '#1a1a2e' : '#151525';
                        
                        ctx.beginPath();
                        ctx.moveTo(camX, camY);
                        ctx.lineTo(camX + tileW, camY + tileH);
                        ctx.lineTo(camX, camY + tileH * 2);
                        ctx.lineTo(camX - tileW, camY + tileH);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
        }

        // ============================================
        // GLOBAL STATE
        // ============================================
        let spriteLoader, renderer;
        let frameCount = 0, lastFpsTime = performance.now();

        // ============================================
        // INITIALIZATION
        // ============================================
        async function init() {
            const canvas = document.getElementById('officeCanvas');
            
            spriteLoader = new SpriteLoader('assets/sprites/');
            await spriteLoader.load();
            
            renderer = new OfficeRenderer(canvas);
            
            AGENTS_DATA.forEach(data => renderer.addAgent(data));
            
            renderer.start();
            
            setInterval(updateFps, 1000);
        }

        function updateFps() {
            const now = performance.now();
            const fps = Math.round(frameCount * 1000 / (now - lastFpsTime));
            document.getElementById('fpsCounter').textContent = fps;
            
            const active = Array.from(renderer.agents.values())
                .filter(a => a.activity !== 'idle').length;
            document.getElementById('activeCounter').textContent = active;
            
            frameCount = 0;
            lastFpsTime = now;
        }

        function resetCamera() {
            if (renderer) {
                renderer.camera.x = 0;
                renderer.camera.y = 0;
                renderer.camera.zoom = 1;
            }
        }

        function toggleDebug() {
            if (renderer) renderer.debug = !renderer.debug;
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
