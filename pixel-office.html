<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Office | Living Pixel Command Center</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-card: #1a1a2e;
            --accent-primary: #00d4ff;
            --accent-cyan: #00d4ff;
            --accent-green: #22c55e;
            --accent-yellow: #fbbf24;
            --accent-orange: #f97316;
            --accent-purple: #a855f7;
            --accent-pink: #ff2a6d;
            --text-primary: #eaeaea;
            --text-secondary: #888;
            --border: #2d2d44;
        }
        
        body {
            font-family: 'VT323', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 212, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 212, 255, 0.02) 1px, transparent 1px);
            background-size: 32px 32px;
            pointer-events: none;
            z-index: 0;
        }
        
        /* Header */
        .header {
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--accent-primary);
            padding: 0 1rem;
            height: 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        
        .brand {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .logo {
            width: 32px;
            height: 32px;
            background: var(--accent-primary);
            border: 2px solid var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }
        
        .brand-text h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.55rem;
            line-height: 1.3;
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.8rem;
            padding: 0.25rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 4px;
        }
        
        .connection-status.connected { border-color: var(--accent-green); color: var(--accent-green); }
        .connection-status.connecting { border-color: var(--accent-yellow); color: var(--accent-yellow); }
        .connection-status.error { border-color: var(--accent-pink); color: var(--accent-pink); }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        /* Main Container */
        .main-container {
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(180deg, #0a0a0f 0%, #12121a 100%);
        }
        
        #officeCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
        }
        
        #officeCanvas:active { cursor: grabbing; }
        
        /* Controls */
        .controls-overlay {
            position: absolute;
            bottom: 15px;
            left: 15px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        
        .control-btn {
            width: 40px;
            height: 40px;
            background: var(--bg-card);
            border: 2px solid var(--accent-cyan);
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .control-btn:hover {
            background: var(--accent-cyan);
            color: var(--bg-primary);
        }
        
        /* Side Panel */
        .side-panel {
            width: 300px;
            background: var(--bg-secondary);
            border-left: 2px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 50;
            transition: transform 0.3s ease;
        }
        
        .panel-section {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border);
        }
        
        .panel-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: var(--accent-cyan);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .agent-list {
            max-height: 180px;
            overflow-y: auto;
        }
        
        .agent-list-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            margin-bottom: 0.4rem;
            cursor: pointer;
            transition: all 0.15s;
            font-size: 0.9rem;
        }
        
        .agent-list-item:hover {
            border-color: var(--accent-cyan);
        }
        
        .agent-list-item.active {
            border-color: var(--accent-green);
            background: rgba(34, 197, 94, 0.1);
        }
        
        .agent-list-avatar {
            width: 28px;
            height: 28px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            border: 1px solid var(--border);
        }
        
        .agent-list-info { flex: 1; }
        .agent-list-name { font-weight: bold; }
        .agent-list-role { font-size: 0.75rem; color: var(--text-secondary); }
        
        .agent-list-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent-green);
        }
        
        .activity-feed {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .activity-item {
            display: flex;
            gap: 0.4rem;
            padding: 0.4rem;
            background: var(--bg-card);
            border-left: 2px solid var(--accent-cyan);
            margin-bottom: 0.4rem;
            font-size: 0.85rem;
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .activity-agent { color: var(--accent-cyan); font-weight: bold; }
        .activity-time { font-size: 0.7rem; color: var(--text-secondary); margin-left: auto; }
        
        .quick-actions {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.4rem;
        }
        
        .action-btn {
            padding: 0.5rem;
            background: var(--bg-card);
            border: 1px solid var(--accent-primary);
            color: var(--text-primary);
            font-family: 'VT323', monospace;
            font-size: 0.85rem;
            cursor: pointer;
        }
        
        .action-btn:hover { background: var(--accent-primary); }
        
        .tooltip {
            position: absolute;
            background: var(--bg-card);
            border: 2px solid var(--accent-cyan);
            padding: 0.5rem;
            pointer-events: none;
            z-index: 200;
            font-size: 0.8rem;
            max-width: 180px;
            display: none;
        }
        
        .tooltip-title {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5rem;
            color: var(--accent-cyan);
        }
        
        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.3s;
        }
        
        .loading-screen.hidden { opacity: 0; pointer-events: none; }
        
        .loading-bar {
            width: 200px;
            height: 6px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            margin-top: 1rem;
        }
        
        .loading-progress {
            height: 100%;
            background: var(--accent-cyan);
            width: 0%;
            transition: width 0.2s;
        }
        
        /* Mobile */
        .mobile-toggle {
            display: none;
            position: absolute;
            top: 70px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: var(--bg-card);
            border: 2px solid var(--accent-cyan);
            color: var(--text-primary);
            z-index: 100;
        }
        
        @media (max-width: 900px) {
            .side-panel {
                position: fixed;
                right: 0;
                top: 50px;
                bottom: 0;
                transform: translateX(100%);
                width: 260px;
            }
            .side-panel.open { transform: translateX(0); }
            .mobile-toggle { display: flex; align-items: center; justify-content: center; }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div style="font-size: 3rem;">üè¢</div>
        <div style="font-family: 'Press Start 2P'; font-size: 0.7rem; margin-top: 0.5rem;">LOADING PIXEL OFFICE...</div>
        <div class="loading-bar">
            <div class="loading-progress" id="loadingProgress"></div>
        </div>
        <div id="loadingStatus" style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-secondary);">Initializing...</div>
    </div>

    <header class="header">
        <div class="brand">
            <div class="logo">üè¢</div>
            <div class="brand-text">
                <h1>PIXEL OFFICE</h1>
            </div>
        </div>
        
        <div class="connection-status" id="connectionStatus">
            <span class="status-dot"></span>
            <span id="connectionText">Connecting...</span>
        </div>
        
        <button class="control-btn" onclick="location.href='mission-control/dashboard/office.html'" title="Back to Dashboard">üè†</button>
    </header>

    <div class="main-container">
        <div class="canvas-container" id="canvasContainer">
            <canvas id="officeCanvas"></canvas>
            
            <div class="controls-overlay">
                <button class="control-btn" onclick="zoomIn()" title="Zoom In">+</button>
                <button class="control-btn" onclick="zoomOut()" title="Zoom Out">‚àí</button>
                <button class="control-btn" onclick="resetView()" title="Reset View">‚åÇ</button>
                <button class="control-btn" onclick="toggleStandup()" title="Standup">üì¢</button>
            </div>
            
            <button class="mobile-toggle" id="mobileToggle" onclick="togglePanel()">‚ò∞</button>
            
            <div class="tooltip" id="tooltip">
                <div class="tooltip-title" id="tooltipTitle"></div>
                <div id="tooltipRole"></div>
                <div style="color: var(--accent-yellow); margin-top: 0.25rem;" id="tooltipTask"></div>
            </div>
        </div>
        
        <aside class="side-panel" id="sidePanel">
            <div class="panel-section">
                <div class="panel-title">üë• AGENTS (<span id="agentCount">0</span>)</div>
                <div class="agent-list" id="agentList"></div>
            </div>
            
            <div class="panel-section" style="flex: 1; overflow: hidden;">
                <div class="panel-title">üì° LIVE ACTIVITY</div>
                <div class="activity-feed" id="activityFeed"></div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">‚ö° ACTIONS</div>
                <div class="quick-actions">
                    <button class="action-btn" onclick="callStandup()">üì¢ Standup</button>
                    <button class="action-btn" onclick="syncWithAPI()">üîÑ Sync</button>
                    <button class="action-btn" onclick="findAgent()">üîç Find</button>
                    <button class="action-btn" onclick="toggleParticles()">‚ú® FX</button>
                </div>
            </div>
        </aside>
    </div>

    <script>
        // ============================================
        // PIXEL OFFICE v2.0 - REAL API INTEGRATION
        // ============================================
        
        const canvas = document.getElementById('officeCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');
        
        ctx.imageSmoothingEnabled = false;
        
        // API Configuration
        const API_CONFIG = {
            baseUrl: '', // Same origin
            endpoints: {
                agents: '/api/agents',
                tasks: '/api/tasks',
                leads: '/api/leads',
                system: '/api/system/status',
                events: '/api/system/events'
            },
            refreshInterval: 30000,
            retryInterval: 5000
        };
        
        // Game State
        const state = {
            zoom: 1,
            panX: 0,
            panY: 0,
            isDragging: false,
            lastMouseX: 0,
            lastMouseY: 0,
            soundEnabled: true,
            particlesEnabled: true,
            standupMode: false,
            lastTime: 0,
            hoveredAgent: null,
            selectedAgent: null,
            apiConnected: false,
            lastApiFetch: 0
        };
        
        // Isometric constants
        const TILE_WIDTH = 48;
        const TILE_HEIGHT = 24;
        const GRID_SIZE = 20;
        
        // Office data
        const office = {
            tiles: [],
            furniture: [],
            agents: [],
            particles: [],
            standupSeats: []
        };
        
        // Default agents data (fallback)
        const defaultAgents = [
            { id: 'ericf', name: 'EricF', role: 'Commander', type: 'human', color: '#ffd700', sprite: 'üëë', x: 10, y: 10, task: 'Overseeing operations', status: 'active' },
            { id: 'nexus', name: 'Nexus', role: 'Orchestrator', type: 'ai', color: '#00d4ff', sprite: 'ü§ñ', x: 8, y: 8, task: 'Coordinating agents', status: 'active' },
            { id: 'codemaster', name: 'CodeMaster', role: 'Backend Lead', type: 'ai', color: '#22c55e', sprite: 'üíª', x: 6, y: 6, task: 'API architecture', status: 'active' },
            { id: 'code1', name: 'Code-1', role: 'Backend Dev', type: 'ai', color: '#22c55e', sprite: '‚ö°', x: 5, y: 7, task: 'Database optimization', status: 'active' },
            { id: 'code2', name: 'Code-2', role: 'Backend Dev', type: 'ai', color: '#22c55e', sprite: 'üîß', x: 7, y: 5, task: 'Fixing API errors', status: 'active' },
            { id: 'code3', name: 'Code-3', role: 'Backend Dev', type: 'ai', color: '#22c55e', sprite: 'üîå', x: 6, y: 8, task: 'Testing endpoints', status: 'active' },
            { id: 'forge', name: 'Forge', role: 'UI/Frontend Lead', type: 'ai', color: '#f97316', sprite: 'üî®', x: 12, y: 6, task: 'Design system', status: 'active' },
            { id: 'forge2', name: 'Forge-2', role: 'UI Developer', type: 'ai', color: '#f97316', sprite: 'üé®', x: 13, y: 5, task: 'Component library', status: 'active' },
            { id: 'forge3', name: 'Forge-3', role: 'UI Developer', type: 'ai', color: '#f97316', sprite: '‚ú®', x: 11, y: 7, task: 'Theme integration', status: 'active' },
            { id: 'pixel', name: 'Pixel', role: 'Designer', type: 'ai', color: '#a855f7', sprite: 'üé®', x: 14, y: 6, task: 'Creating assets', status: 'active' },
            { id: 'glasses', name: 'Glasses', role: 'Researcher', type: 'ai', color: '#3b82f6', sprite: 'üîç', x: 4, y: 10, task: 'Market analysis', status: 'active' },
            { id: 'quill', name: 'Quill', role: 'Writer', type: 'ai', color: '#ec4899', sprite: 'üìù', x: 3, y: 12, task: 'Documentation', status: 'active' },
            { id: 'gary', name: 'Gary', role: 'Marketing', type: 'ai', color: '#f59e0b', sprite: 'üì¢', x: 16, y: 8, task: 'Campaign planning', status: 'active' },
            { id: 'larry', name: 'Larry', role: 'Social Media', type: 'ai', color: '#06b6d4', sprite: 'üì±', x: 17, y: 9, task: 'Content scheduling', status: 'active' },
            { id: 'sentry', name: 'Sentry', role: 'DevOps', type: 'ai', color: '#ef4444', sprite: 'üõ°Ô∏è', x: 9, y: 12, task: 'Server monitoring', status: 'active' },
            { id: 'audit', name: 'Audit', role: 'QA Lead', type: 'ai', color: '#8b5cf6', sprite: 'üîç', x: 8, y: 14, task: 'Quality assurance', status: 'active' },
            { id: 'cipher', name: 'Cipher', role: 'Security', type: 'ai', color: '#6366f1', sprite: 'üîê', x: 10, y: 14, task: 'Security audit', status: 'active' },
            { id: 'dealflow', name: 'DealFlow', role: 'Lead Gen', type: 'ai', color: '#10b981', sprite: 'ü§ù', x: 15, y: 12, task: 'Lead research', status: 'active' },
            { id: 'coldcall', name: 'ColdCall', role: 'Outreach', type: 'ai', color: '#f97316', sprite: 'üìû', x: 16, y: 13, task: 'Cold calling', status: 'active' },
            { id: 'scout', name: 'Scout', role: 'Intel', type: 'ai', color: '#3b82f6', sprite: 'üî≠', x: 5, y: 14, task: 'Competitor intel', status: 'active' },
            { id: 'pie', name: 'PIE', role: 'Predictive AI', type: 'ai', color: '#8b5cf6', sprite: 'üß†', x: 10, y: 4, task: 'Data analysis', status: 'active' }
        ];
        
        // ============================================
        // API INTEGRATION (CodeMaster)
        // ============================================
        
        async function fetchFromAPI(endpoint) {
            try {
                const response = await fetch(`${API_CONFIG.baseUrl}${endpoint}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.json();
            } catch (error) {
                console.warn(`API fetch failed for ${endpoint}:`, error.message);
                return null;
            }
        }
        
        async function syncWithAPI() {
            updateLoadingStatus('Syncing with API...');
            
            const [agents, tasks, system] = await Promise.all([
                fetchFromAPI(API_CONFIG.endpoints.agents),
                fetchFromAPI(API_CONFIG.endpoints.tasks),
                fetchFromAPI(API_CONFIG.endpoints.system)
            ]);
            
            if (agents) {
                updateAgentsFromAPI(agents);
                state.apiConnected = true;
                updateConnectionStatus('connected', 'Live');
                addActivity('system', 'API', 'Synced agent data');
            } else {
                state.apiConnected = false;
                updateConnectionStatus('error', 'Offline Mode');
                addActivity('system', 'API', 'Using cached data');
            }
            
            if (tasks) {
                updateTasksFromAPI(tasks);
            }
            
            state.lastApiFetch = Date.now();
            updateLoadingStatus('Ready!');
        }
        
        function updateAgentsFromAPI(apiData) {
            if (!apiData || !Array.isArray(apiData)) return;
            
            apiData.forEach(apiAgent => {
                const agent = office.agents.find(a => a.id === apiAgent.id || a.name === apiAgent.name);
                if (agent) {
                    // Update from API
                    if (apiAgent.status) agent.status = apiAgent.status;
                    if (apiAgent.currentTask) agent.task = apiAgent.currentTask;
                    if (apiAgent.activity) agent.activity = apiAgent.activity;
                    
                    // Update position if provided
                    if (apiAgent.position) {
                        agent.targetX = apiAgent.position.x * TILE_WIDTH;
                        agent.targetY = apiAgent.position.y * TILE_HEIGHT;
                        agent.isMoving = true;
                    }
                }
            });
            
            renderAgentList();
        }
        
        function updateTasksFromAPI(tasks) {
            if (!tasks) return;
            
            // Distribute tasks to agents
            const activeTasks = tasks.filter(t => t.status === 'in_progress' || t.status === 'pending');
            
            office.agents.forEach((agent, i) => {
                if (activeTasks[i]) {
                    agent.task = activeTasks[i].title || activeTasks[i].description;
                }
            });
        }
        
        function updateConnectionStatus(status, text) {
            const statusEl = document.getElementById('connectionStatus');
            const textEl = document.getElementById('connectionText');
            
            statusEl.className = `connection-status ${status}`;
            textEl.textContent = text;
        }
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        function initOffice() {
            // Generate floor tiles
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    office.tiles.push({
                        x, y,
                        type: (x + y) % 2 === 0 ? 'floor1' : 'floor2'
                    });
                }
            }
            
            // Furniture
            office.furniture = [
                { x: 5, y: 5, type: 'desk' }, { x: 6, y: 5, type: 'desk' },
                { x: 5, y: 6, type: 'desk' }, { x: 6, y: 6, type: 'desk' },
                { x: 12, y: 5, type: 'desk' }, { x: 13, y: 5, type: 'desk' },
                { x: 12, y: 6, type: 'desk' }, { x: 13, y: 6, type: 'desk' },
                { x: 8, y: 10, type: 'server' },
                { x: 10, y: 2, type: 'conference' }
            ];
            
            // Initialize agents
            office.agents = defaultAgents.map(data => ({
                ...data,
                pixelX: data.x * TILE_WIDTH,
                pixelY: data.y * TILE_HEIGHT,
                targetX: data.x * TILE_WIDTH,
                targetY: data.y * TILE_HEIGHT,
                direction: Math.floor(Math.random() * 4),
                isMoving: false,
                walkCycle: 0,
                activity: 'working',
                activityTimer: Math.random() * 100,
                speechBubble: null,
                speechTimer: 0
            }));
            
            // Standup seats
            office.standupSeats = [
                { x: 8, y: 3 }, { x: 9, y: 3 }, { x: 10, y: 3 }, { x: 11, y: 3 },
                { x: 8, y: 4 }, { x: 11, y: 4 },
                { x: 8, y: 5 }, { x: 9, y: 5 }, { x: 10, y: 5 }, { x: 11, y: 5 }
            ];
        }
        
        // ============================================
        // ISOMETRIC RENDERING
        // ============================================
        
        function toIso(x, y) {
            return {
                x: (x - y) * (TILE_WIDTH / 2),
                y: (x + y) * (TILE_HEIGHT / 2)
            };
        }
        
        function fromIso(isoX, isoY) {
            return {
                x: (isoX / (TILE_WIDTH / 2) + isoY / (TILE_HEIGHT / 2)) / 2,
                y: (isoY / (TILE_HEIGHT / 2) - isoX / (TILE_WIDTH / 2)) / 2
            };
        }
        
        // ============================================
        // SPRITE RENDERING (Pixel)
        // ============================================
        
        function drawAgentSprite(agent, screenX, screenY, scale) {
            const size = 20 * scale;
            const bounce = agent.isMoving ? Math.sin(agent.walkCycle * 0.5) * 2 * scale : 0;
            const x = screenX;
            const y = screenY - size - bounce;
            
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x, screenY, size * 0.6, size * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Body
            const bodyColor = agent.color;
            const darkColor = adjustColor(bodyColor, -30);
            
            // Walking animation
            const walkOffset = agent.isMoving ? Math.sin(agent.walkCycle) * 3 * scale : 0;
            const dir = agent.direction;
            
            // Body
            ctx.fillStyle = bodyColor;
            ctx.fillRect(x - size/2, y, size, size * 0.9);
            
            // Head
            const headSize = size * 0.7;
            const headY = y - headSize + 3;
            ctx.fillStyle = '#ffdbac';
            ctx.fillRect(x - headSize/2, headY, headSize, headSize);
            
            // Face
            ctx.fillStyle = '#333';
            if (dir === 0) { // Down
                ctx.fillRect(x - 3, headY + 8, 2, 2);
                ctx.fillRect(x + 1, headY + 8, 2, 2);
            } else if (dir !== 3) { // Side
                const eyeX = dir === 1 ? x - 4 : x + 2;
                ctx.fillRect(eyeX, headY + 8, 2, 2);
            }
            
            // Hair/Hat
            ctx.fillStyle = darkColor;
            ctx.fillRect(x - headSize/2 - 1, headY - 2, headSize + 2, 4);
            
            // Arms
            if (dir === 1 || dir === 2) {
                const armX = dir === 1 ? x - size/2 - 4 : x + size/2;
                ctx.fillStyle = bodyColor;
                ctx.fillRect(armX, y + 3, 4, size * 0.5);
            } else {
                ctx.fillRect(x - size/2 - 3, y + 3 + walkOffset, 3, size * 0.4);
                ctx.fillRect(x + size/2, y + 3 - walkOffset, 3, size * 0.4);
            }
            
            // Legs
            if (agent.isMoving) {
                const legOffset = Math.sin(agent.walkCycle) * 3 * scale;
                ctx.fillStyle = '#333';
                ctx.fillRect(x - size/3, y + size * 0.7, size/3 - 1, size * 0.3 + legOffset);
                ctx.fillRect(x + 1, y + size * 0.7, size/3 - 1, size * 0.3 - legOffset);
            } else {
                ctx.fillStyle = '#333';
                ctx.fillRect(x - size/3, y + size * 0.7, size/3 - 1, size * 0.3);
                ctx.fillRect(x + 1, y + size * 0.7, size/3 - 1, size * 0.3);
            }
            
            // Human crown
            if (agent.type === 'human') {
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(x - 6, headY - 6, 12, 4);
                ctx.fillRect(x - 4, headY - 10, 3, 4);
                ctx.fillRect(x + 1, headY - 10, 3, 4);
                
                // Glow
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 8;
                ctx.strokeStyle = '#ffd700';
                ctx.strokeRect(x - size/2 - 1, y - 1, size + 2, size + headSize);
                ctx.shadowBlur = 0;
            }
        }
        
        function drawFurniture(fur, x, y, scale) {
            const size = TILE_WIDTH * scale;
            
            switch(fur.type) {
                case 'desk':
                    ctx.fillStyle = '#8b7355';
                    ctx.fillRect(x - size/2, y - size/4, size, size/2);
                    ctx.fillStyle = '#00d4ff';
                    ctx.fillRect(x - 8, y - size/3 - 12, 16, 10);
                    break;
                case 'server':
                    ctx.fillStyle = '#2d3748';
                    ctx.fillRect(x - size/3, y - size/2, size/1.5, size);
                    const blink = Math.sin(Date.now() / 150) > 0;
                    ctx.fillStyle = blink ? '#22c55e' : '#166534';
                    ctx.fillRect(x - size/3 + 3, y - size/2 + 3, 4, 4);
                    break;
                case 'conference':
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(x - size, y - size/3, size * 2, size/1.5);
                    break;
            }
        }
        
        function drawTile(tile, x, y, scale) {
            const w = TILE_WIDTH * scale;
            const h = TILE_HEIGHT * scale;
            
            ctx.fillStyle = tile.type === 'floor1' ? '#1a1a2e' : '#252540';
            ctx.beginPath();
            ctx.moveTo(x, y - h/2);
            ctx.lineTo(x + w/2, y);
            ctx.lineTo(x, y + h/2);
            ctx.lineTo(x - w/2, y);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = '#0f0f1a';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        
        function drawActivityBar(agent, x, y, scale) {
            const w = 36 * scale;
            const h = 3 * scale;
            const bx = x - w/2;
            const by = y - 45 * scale;
            
            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(bx - 1, by - 12, w + 2, 18);
            
            // Name
            ctx.fillStyle = '#fff';
            ctx.font = `${Math.floor(7 * scale)}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            const emoji = { working: 'üíª', meeting: 'üìû', break: '‚òï', completed: '‚úÖ' }[agent.activity] || 'üíª';
            ctx.fillText(emoji + ' ' + agent.name, x, by - 2);
            
            // Progress bar
            ctx.fillStyle = '#333';
            ctx.fillRect(bx, by + 2, w, h);
            
            const colors = { working: '#00d4ff', meeting: '#a855f7', break: '#fbbf24', completed: '#22c55e' };
            ctx.fillStyle = colors[agent.activity] || '#00d4ff';
            ctx.fillRect(bx, by + 2, w * ((agent.activityTimer % 100) / 100), h);
        }
        
        function drawSpeechBubble(agent, x, y, scale) {
            if (!agent.speechBubble) return;
            
            ctx.font = `${Math.floor(8 * scale)}px 'VT323'`;
            const text = agent.speechBubble;
            const width = ctx.measureText(text).width + 10;
            const height = 16 * scale;
            const bx = x - width/2;
            const by = y - 55 * scale - height;
            
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.fillRect(bx, by, width, height);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(bx, by, width, height);
            
            ctx.fillStyle = '#333';
            ctx.textAlign = 'left';
            ctx.fillText(text, bx + 5, by + 11 * scale);
        }
        
        // ============================================
        // PARTICLES
        // ============================================
        
        function createParticle(x, y, type) {
            const colors = {
                work: ['#00d4ff', '#22c55e'],
                meeting: ['#a855f7', '#ec4899'],
                completed: ['#22c55e', '#fbbf24']
            };
            const colorSet = colors[type] || colors.work;
            
            return {
                x, y,
                vx: (Math.random() - 0.5) * 1.5,
                vy: -Math.random() * 1.5 - 0.5,
                life: 1,
                decay: 0.02,
                color: colorSet[Math.floor(Math.random() * colorSet.length)],
                size: 2
            };
        }
        
        function updateParticles() {
            office.particles = office.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;
                return p.life > 0;
            });
        }
        
        function drawParticles() {
            office.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1;
        }
        
        // ============================================
        // RENDER LOOP
        // ============================================
        
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const cx = canvas.width / 2 + state.panX;
            const cy = canvas.height / 2 + state.panY;
            const scale = state.zoom;
            
            const renderList = [];
            
            // Collect tiles
            office.tiles.forEach(tile => {
                const iso = toIso(tile.x, tile.y);
                renderList.push({
                    type: 'tile',
                    obj: tile,
                    y: tile.y,
                    screenX: cx + iso.x * scale,
                    screenY: cy + iso.y * scale
                });
            });
            
            // Collect furniture
            office.furniture.forEach(fur => {
                const iso = toIso(fur.x, fur.y);
                renderList.push({
                    type: 'furniture',
                    obj: fur,
                    y: fur.y,
                    screenX: cx + iso.x * scale,
                    screenY: cy + iso.y * scale
                });
            });
            
            // Collect agents
            office.agents.forEach(agent => {
                const iso = toIso(agent.pixelX / TILE_WIDTH, agent.pixelY / TILE_HEIGHT);
                renderList.push({
                    type: 'agent',
                    obj: agent,
                    y: agent.pixelY / TILE_HEIGHT,
                    screenX: cx + iso.x * scale,
                    screenY: cy + iso.y * scale
                });
            });
            
            // Sort by depth
            renderList.sort((a, b) => a.y - b.y);
            
            // Render
            renderList.forEach(item => {
                switch(item.type) {
                    case 'tile':
                        drawTile(item.obj, item.screenX, item.screenY, scale);
                        break;
                    case 'furniture':
                        drawFurniture(item.obj, item.screenX, item.screenY, scale);
                        break;
                    case 'agent':
                        drawAgentSprite(item.obj, item.screenX, item.screenY, scale);
                        drawActivityBar(item.obj, item.screenX, item.screenY, scale);
                        drawSpeechBubble(item.obj, item.screenX, item.screenY, scale);
                        
                        if (state.particlesEnabled && Math.random() < 0.015) {
                            office.particles.push(createParticle(
                                item.screenX, item.screenY - 25 * scale, item.obj.activity
                            ));
                        }
                        break;
                }
            });
            
            if (state.particlesEnabled) drawParticles();
            
            // Standup highlight
            if (state.standupMode) {
                office.standupSeats.forEach(seat => {
                    const iso = toIso(seat.x, seat.y);
                    const x = cx + iso.x * scale;
                    const y = cy + iso.y * scale;
                    ctx.fillStyle = 'rgba(251, 191, 36, 0.2)';
                    ctx.beginPath();
                    ctx.moveTo(x, y - TILE_HEIGHT * scale / 2);
                    ctx.lineTo(x + TILE_WIDTH * scale / 2, y);
                    ctx.lineTo(x, y + TILE_HEIGHT * scale / 2);
                    ctx.lineTo(x - TILE_WIDTH * scale / 2, y);
                    ctx.closePath();
                    ctx.fill();
                });
            }
        }
        
        // ============================================
        // GAME LOGIC
        // ============================================
        
        function updateAgents(deltaTime) {
            office.agents.forEach(agent => {
                agent.walkCycle += deltaTime * 0.01;
                
                // Random movement
                if (!agent.isMoving && Math.random() < 0.003) {
                    const tx = agent.pixelX + (Math.random() - 0.5) * TILE_WIDTH * 2;
                    const ty = agent.pixelY + (Math.random() - 0.5) * TILE_HEIGHT * 2;
                    
                    if (tx > 0 && tx < GRID_SIZE * TILE_WIDTH &&
                        ty > 0 && ty < GRID_SIZE * TILE_HEIGHT) {
                        agent.targetX = tx;
                        agent.targetY = ty;
                        agent.isMoving = true;
                        
                        const dx = tx - agent.pixelX;
                        const dy = ty - agent.pixelY;
                        agent.direction = Math.abs(dx) > Math.abs(dy) 
                            ? (dx > 0 ? 2 : 1) 
                            : (dy > 0 ? 0 : 3);
                    }
                }
                
                // Move
                if (agent.isMoving) {
                    const dx = agent.targetX - agent.pixelX;
                    const dy = agent.targetY - agent.pixelY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 1) {
                        agent.isMoving = false;
                        agent.pixelX = agent.targetX;
                        agent.pixelY = agent.targetY;
                    } else {
                        agent.pixelX += (dx / dist) * 0.6;
                        agent.pixelY += (dy / dist) * 0.6;
                    }
                }
                
                // Update activity
                agent.activityTimer += deltaTime * 0.01;
                if (agent.activityTimer > 100) {
                    agent.activityTimer = 0;
                    const acts = ['working', 'meeting', 'break', 'completed'];
                    agent.activity = acts[Math.floor(Math.random() * acts.length)];
                }
                
                // Speech bubble
                if (!agent.speechBubble && Math.random() < 0.0008) {
                    const msgs = ['Working!', 'Almost done!', 'On it!', 'Bug fixed!'];
                    agent.speechBubble = msgs[Math.floor(Math.random() * msgs.length)];
                    agent.speechTimer = 2500;
                }
                
                if (agent.speechBubble) {
                    agent.speechTimer -= deltaTime;
                    if (agent.speechTimer <= 0) agent.speechBubble = null;
                }
            });
        }
        
        function gameLoop(currentTime) {
            const deltaTime = currentTime - state.lastTime;
            state.lastTime = currentTime;
            
            updateAgents(deltaTime);
            updateParticles();
            render();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ============================================
        // INPUT (Forge)
        // ============================================
        
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }
        
        function screenToWorld(sx, sy) {
            const cx = canvas.width / 2 + state.panX;
            const cy = canvas.height / 2 + state.panY;
            return fromIso((sx - cx) / state.zoom, (sy - cy) / state.zoom);
        }
        
        canvas.addEventListener('mousedown', e => {
            state.isDragging = true;
            state.lastMouseX = e.clientX;
            state.lastMouseY = e.clientY;
            
            const pos = getMousePos(e);
            const world = screenToWorld(pos.x, pos.y);
            
            office.agents.forEach(agent => {
                const ax = agent.pixelX / TILE_WIDTH;
                const ay = agent.pixelY / TILE_HEIGHT;
                if (Math.hypot(world.x - ax, world.y - ay) < 0.7) {
                    selectAgent(agent);
                }
            });
        });
        
        canvas.addEventListener('mousemove', e => {
            const pos = getMousePos(e);
            
            if (state.isDragging) {
                state.panX += e.clientX - state.lastMouseX;
                state.panY += e.clientY - state.lastMouseY;
                state.lastMouseX = e.clientX;
                state.lastMouseY = e.clientY;
            }
            
            const world = screenToWorld(pos.x, pos.y);
            let hovered = null;
            
            office.agents.forEach(agent => {
                const ax = agent.pixelX / TILE_WIDTH;
                const ay = agent.pixelY / TILE_HEIGHT;
                if (Math.hypot(world.x - ax, world.y - ay) < 0.7) {
                    hovered = agent;
                }
            });
            
            state.hoveredAgent = hovered;
            updateTooltip(hovered, e.clientX, e.clientY);
        });
        
        canvas.addEventListener('mouseup', () => state.isDragging = false);
        canvas.addEventListener('mouseleave', () => {
            state.isDragging = false;
            state.hoveredAgent = null;
            document.getElementById('tooltip').style.display = 'none';
        });
        
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            state.zoom = Math.max(0.5, Math.min(3, state.zoom * delta));
        });
        
        // Touch support
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.touches[0];
            state.isDragging = true;
            state.lastMouseX = t.clientX;
            state.lastMouseY = t.clientY;
        });
        
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (state.isDragging) {
                const t = e.touches[0];
                state.panX += t.clientX - state.lastMouseX;
                state.panY += t.clientY - state.lastMouseY;
                state.lastMouseX = t.clientX;
                state.lastMouseY = t.clientY;
            }
        });
        
        canvas.addEventListener('touchend', () => state.isDragging = false);
        
        // ============================================
        // UI FUNCTIONS
        // ============================================
        
        function zoomIn() { state.zoom = Math.min(3, state.zoom * 1.2); }
        function zoomOut() { state.zoom = Math.max(0.5, state.zoom / 1.2); }
        function resetView() { state.zoom = 1; state.panX = 0; state.panY = 0; }
        
        function toggleStandup() {
            state.standupMode = !state.standupMode;
            
            office.agents.forEach((agent, i) => {
                if (state.standupMode && i < office.standupSeats.length) {
                    const seat = office.standupSeats[i];
                    agent.targetX = seat.x * TILE_WIDTH;
                    agent.targetY = seat.y * TILE_HEIGHT;
                    agent.isMoving = true;
                    agent.activity = 'meeting';
                } else if (!state.standupMode) {
                    const data = defaultAgents[i];
                    agent.targetX = data.x * TILE_WIDTH;
                    agent.targetY = data.y * TILE_HEIGHT;
                    agent.isMoving = true;
                    agent.activity = 'working';
                }
            });
        }
        
        function togglePanel() {
            document.getElementById('sidePanel').classList.toggle('open');
        }
        
        function toggleParticles() {
            state.particlesEnabled = !state.particlesEnabled;
        }
        
        function selectAgent(agent) {
            state.selectedAgent = agent;
            agent.speechBubble = 'Yes, Commander?';
            agent.speechTimer = 2000;
            
            document.querySelectorAll('.agent-list-item').forEach(el => {
                el.classList.toggle('active', el.dataset.id === agent.id);
            });
        }
        
        function updateTooltip(agent, x, y) {
            const tt = document.getElementById('tooltip');
            if (agent) {
                document.getElementById('tooltipTitle').textContent = agent.name;
                document.getElementById('tooltipRole').textContent = agent.role;
                document.getElementById('tooltipTask').textContent = agent.task;
                tt.style.display = 'block';
                tt.style.left = (x + 10) + 'px';
                tt.style.top = (y + 10) + 'px';
            } else {
                tt.style.display = 'none';
            }
        }
        
        function renderAgentList() {
            const list = document.getElementById('agentList');
            list.innerHTML = '';
            
            office.agents.forEach(agent => {
                const item = document.createElement('div');
                item.className = 'agent-list-item';
                item.dataset.id = agent.id;
                item.innerHTML = `
                    <div class="agent-list-avatar" style="background: ${agent.color}20; border-color: ${agent.color};">${agent.sprite}</div>
                    <div class="agent-list-info">
                        <div class="agent-list-name">${agent.name}</div>
                        <div class="agent-list-role">${agent.role}</div>
                    </div>
                    <div class="agent-list-status ${agent.activity}"></div>
                `;
                item.onclick = () => {
                    selectAgent(agent);
                    const iso = toIso(agent.pixelX / TILE_WIDTH, agent.pixelY / TILE_HEIGHT);
                    state.panX = -iso.x * state.zoom;
                    state.panY = -iso.y * state.zoom;
                };
                list.appendChild(item);
            });
            
            document.getElementById('agentCount').textContent = office.agents.length;
        }
        
        function addActivity(type, agent, msg) {
            const feed = document.getElementById('activityFeed');
            const item = document.createElement('div');
            item.className = 'activity-item';
            
            const icons = { working: 'üíª', meeting: 'üìû', completed: '‚úÖ', system: '‚ö°' };
            const time = new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
            
            item.innerHTML = `
                <span>${icons[type] || 'üíª'}</span>
                <div style="flex: 1;"><span class="activity-agent">${agent}</span> ${msg}</div>
                <span class="activity-time">${time}</span>
            `;
            
            feed.insertBefore(item, feed.firstChild);
            while (feed.children.length > 15) feed.removeChild(feed.lastChild);
        }
        
        function callStandup() {
            toggleStandup();
            addActivity('meeting', 'System', 'Daily standup ' + (state.standupMode ? 'started' : 'ended'));
        }
        
        function findAgent() {
            const agent = office.agents[Math.floor(Math.random() * office.agents.length)];
            selectAgent(agent);
            const iso = toIso(agent.pixelX / TILE_WIDTH, agent.pixelY / TILE_HEIGHT);
            state.panX = -iso.x * state.zoom;
            state.panY = -iso.y * state.zoom;
        }
        
        // ============================================
        // UTILITIES
        // ============================================
        
        function adjustColor(color, amount) {
            const num = parseInt(color.replace('#', ''), 16);
            const r = Math.min(255, Math.max(0, (num >> 16) + amount));
            const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
            const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
            return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
        }
        
        function resizeCanvas() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        function updateLoadingStatus(text) {
            document.getElementById('loadingStatus').textContent = text;
        }
        
        // ============================================
        // INIT
        // ============================================
        
        async function init() {
            // Loading animation
            const progress = document.getElementById('loadingProgress');
            let pct = 0;
            const interval = setInterval(() => {
                pct += 20;
                progress.style.width = pct + '%';
                if (pct >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        document.getElementById('loadingScreen').classList.add('hidden');
                    }, 200);
                }
            }, 40);
            
            initOffice();
            resizeCanvas();
            renderAgentList();
            
            // Try to connect to API
            updateLoadingStatus('Connecting to API...');
            await syncWithAPI();
            
            // Start loop
            requestAnimationFrame(gameLoop);
            
            // Initial activities
            addActivity('system', 'Nexus', 'Pixel Office v2.0 initialized');
            addActivity('working', 'CodeMaster', 'API connection established');
            
            // Periodic updates
            setInterval(() => {
                const acts = [
                    { type: 'working', agent: 'Code-1', msg: 'debugging API' },
                    { type: 'completed', agent: 'Forge', msg: 'completed UI update' },
                    { type: 'working', agent: 'DealFlow', msg: 'generated leads' }
                ];
                const a = acts[Math.floor(Math.random() * acts.length)];
                addActivity(a.type, a.agent, a.msg);
            }, 10000);
            
            // Auto-sync every 30s
            setInterval(() => {
                if (Date.now() - state.lastApiFetch > API_CONFIG.refreshInterval) {
                    syncWithAPI();
                }
            }, 5000);
            
            window.addEventListener('resize', resizeCanvas);
            
            // Keyboard
            document.addEventListener('keydown', e => {
                if (e.key === '+' || e.key === '=') zoomIn();
                if (e.key === '-') zoomOut();
                if (e.key === '0') resetView();
                if (e.key === 'm' || e.key === 'M') toggleStandup();
            });
        }
        
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>