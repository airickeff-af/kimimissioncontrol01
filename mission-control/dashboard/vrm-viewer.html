<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#2d1b4e">
    <title>VRM Viewer | Meebit #11318</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }
        
        /* Loading Screen - MUST BE VISIBLE */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #0a0a0f 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        
        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(0, 212, 255, 0.2);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 2rem;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 1.5rem;
            color: #00d4ff;
            margin-bottom: 1rem;
            text-align: center;
        }
        
        .loading-subtext {
            font-size: 0.9rem;
            color: #666;
            text-align: center;
            max-width: 400px;
        }
        
        .loading-progress {
            width: 300px;
            height: 4px;
            background: rgba(0, 212, 255, 0.2);
            border-radius: 2px;
            margin-top: 1.5rem;
            overflow: hidden;
        }
        
        .loading-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* Error Screen */
        #errorScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #0a0a0f 100%);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9998;
        }
        
        #errorScreen.visible {
            display: flex;
        }
        
        .error-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
        }
        
        .error-text {
            font-size: 1.5rem;
            color: #ff4444;
            margin-bottom: 1rem;
        }
        
        .error-details {
            font-size: 0.9rem;
            color: #666;
            text-align: center;
            max-width: 500px;
            margin-bottom: 2rem;
        }
        
        .retry-btn {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            border: none;
            border-radius: 8px;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.2s;
        }
        
        .retry-btn:hover {
            transform: translateY(-2px);
        }
        
        /* VRM Container */
        #vrmContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* UI Overlay */
        #uiOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        #uiOverlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 1.5rem 2rem;
            background: linear-gradient(180deg, rgba(10,10,15,0.9) 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }
        
        .logo {
            font-size: 1.2rem;
            font-weight: 700;
            color: #00d4ff;
        }
        
        .meebit-info {
            text-align: right;
        }
        
        .meebit-id {
            font-size: 1rem;
            color: #fff;
            font-weight: 600;
        }
        
        .meebit-type {
            font-size: 0.8rem;
            color: #888;
        }
        
        .controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 1rem;
            pointer-events: auto;
        }
        
        .control-btn {
            padding: 0.75rem 1.5rem;
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid #00d4ff;
            border-radius: 8px;
            color: #00d4ff;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:hover {
            background: rgba(0, 212, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .fullscreen-btn {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #ff6b9d, #ff8fab);
            border: none;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .fullscreen-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
        }
        
        .fullscreen-btn.hidden {
            display: none;
        }
        
        .back-btn {
            position: absolute;
            top: 1.5rem;
            left: 2rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid #00d4ff;
            border-radius: 6px;
            color: #00d4ff;
            text-decoration: none;
            font-size: 0.85rem;
            transition: all 0.2s;
            pointer-events: auto;
        }
        
        .back-btn:hover {
            background: rgba(0, 212, 255, 0.2);
        }
        
        /* Exit fullscreen hint */
        .exit-hint {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.75rem 1.5rem;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            color: #fff;
            font-size: 0.9rem;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        
        .exit-hint.visible {
            opacity: 1;
        }
        
        /* Status indicator for AI mode */
        .ai-status {
            position: absolute;
            top: 2rem;
            right: 2rem;
            padding: 0.5rem 1rem;
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
            border-radius: 8px;
            color: #00ff88;
            font-size: 0.85rem;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        
        .ai-status.visible {
            opacity: 1;
        }
        
        .ai-status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #00ff88;
            border-radius: 50%;
            margin-right: 0.5rem;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
    </style>
    <!-- Load Three.js and VRM libraries BEFORE any other code -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js"
        }
    }
    </script>
</head>
<body>
    <!-- Loading Screen - Visible immediately -->
    <div id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Meebit #11318</div>
        <div class="loading-subtext">Downloading VRM model from Meebits...</div>
        <div class="loading-progress">
            <div class="loading-progress-bar" id="progressBar"></div>
        </div>
    </div>
    
    <!-- Error Screen -->
    <div id="errorScreen">
        <div class="error-icon">‚ö†Ô∏è</div>
        <div class="error-text">Failed to Load VRM</div>
        <div class="error-details" id="errorDetails">Unable to load the VRM file. This may be due to CORS restrictions or network issues.</div>
        <button class="retry-btn" onclick="location.reload()">Retry</button>
    </div>
    
    <!-- VRM Container -->
    <div id="vrmContainer"></div>
    
    <!-- UI Overlay -->
    <div id="uiOverlay">
        <a href="/dashboard/office.html" class="back-btn">‚Üê Back to Office</a>
        <div class="header">
            <div class="logo">üéØ Mission Control</div>
            <div class="meebit-info">
                <div class="meebit-id">Meebit #11318</div>
                <div class="meebit-type">VRM Avatar</div>
            </div>
        </div>
        <div class="controls">
            <button class="control-btn" id="resetBtn">Reset View</button>
            <button class="control-btn" id="animBtn">Toggle Animation</button>
        </div>
        <button class="fullscreen-btn" id="fullscreenBtn">
            <span>‚õ∂</span> Enter Office
        </button>
        <div class="exit-hint" id="exitHint">Press ESC to exit fullscreen</div>
        <div class="ai-status" id="aiStatus">
            <span class="ai-status-dot"></span>AI Mode Active
        </div>
    </div>

    <script type="module">
        // VRM Loading Script - Runs immediately
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        // Configuration
        const VRM_URL = 'https://files.meebits.app/vrm/11318.vrm';
        const CORS_PROXIES = [
            'https://api.allorigins.win/raw?url=',
            'https://corsproxy.io/?',
            'https://api.codetabs.com/v1/proxy?quest='
        ];

        // State
        let vrm = null;
        let mixer = null;
        let clock = new THREE.Clock();
        let currentProxyIndex = 0;
        let isFullscreen = false;
        let isAIMode = false;
        
        // AI/Animation State
        let characterState = 'idle';
        let targetPosition = null;
        let currentFurniture = null;
        let walkSpeed = 1.5;
        let rotationSpeed = 3.0;
        let animationTimer = 0;
        let furniture = [];
        
        // Three.js globals
        let scene, camera, renderer, controls;
        let cameraOffset = new THREE.Vector3(0, 1.6, 3);
        let cameraTarget = new THREE.Vector3();

        // DOM Elements
        const loadingScreen = document.getElementById('loadingScreen');
        const progressBar = document.getElementById('progressBar');
        const errorScreen = document.getElementById('errorScreen');
        const errorDetails = document.getElementById('errorDetails');
        const container = document.getElementById('vrmContainer');
        const uiOverlay = document.getElementById('uiOverlay');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const exitHint = document.getElementById('exitHint');
        const aiStatus = document.getElementById('aiStatus');

        // Update progress
        function updateProgress(percent) {
            progressBar.style.width = percent + '%';
        }

        // Show error
        function showError(message) {
            loadingScreen.classList.add('hidden');
            errorDetails.textContent = message;
            errorScreen.classList.add('visible');
        }

        // Create office furniture
        function createFurniture() {
            const furnitureGroup = [];
            
            // Sofa
            const sofa = createSofa();
            sofa.position.set(-2, 0, -2);
            sofa.rotation.y = Math.PI / 4;
            scene.add(sofa);
            furnitureGroup.push({
                type: 'sofa',
                object: sofa,
                position: new THREE.Vector3(-2, 0, -2),
                sitPosition: new THREE.Vector3(-2, 0.4, -2),
                interactTime: 5000
            });
            
            // Computer desk
            const desk = createDesk();
            desk.position.set(2, 0, -2);
            desk.rotation.y = -Math.PI / 4;
            scene.add(desk);
            furnitureGroup.push({
                type: 'computer',
                object: desk,
                position: new THREE.Vector3(2, 0, -2),
                sitPosition: new THREE.Vector3(1.6, 0.5, -1.6),
                interactTime: 8000
            });
            
            // Coffee table
            const table = createCoffeeTable();
            table.position.set(0, 0, 1);
            scene.add(table);
            furnitureGroup.push({
                type: 'table',
                object: table,
                position: new THREE.Vector3(0, 0, 1),
                sitPosition: new THREE.Vector3(0, 0.4, 1),
                interactTime: 4000
            });
            
            // Plant/decoration
            const plant = createPlant();
            plant.position.set(-2.5, 0, 2);
            scene.add(plant);
            furnitureGroup.push({
                type: 'decoration',
                object: plant,
                position: new THREE.Vector3(-2.5, 0, 2),
                sitPosition: new THREE.Vector3(-2.2, 0, 2),
                interactTime: 2000
            });
            
            // Bookshelf
            const bookshelf = createBookshelf();
            bookshelf.position.set(2.5, 0, 2);
            scene.add(bookshelf);
            furnitureGroup.push({
                type: 'bookshelf',
                object: bookshelf,
                position: new THREE.Vector3(2.5, 0, 2),
                sitPosition: new THREE.Vector3(2.2, 0, 2),
                interactTime: 3000
            });
            
            return furnitureGroup;
        }
        
        // Create sofa
        function createSofa() {
            const group = new THREE.Group();
            
            // Base
            const baseGeo = new THREE.BoxGeometry(1.8, 0.4, 0.8);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 0.2;
            base.castShadow = true;
            base.receiveShadow = true;
            group.add(base);
            
            // Back
            const backGeo = new THREE.BoxGeometry(1.8, 0.6, 0.2);
            const back = new THREE.Mesh(backGeo, baseMat);
            back.position.set(0, 0.5, -0.3);
            back.castShadow = true;
            group.add(back);
            
            // Armrests
            const armGeo = new THREE.BoxGeometry(0.2, 0.5, 0.8);
            const armLeft = new THREE.Mesh(armGeo, baseMat);
            armLeft.position.set(-0.8, 0.45, 0);
            armLeft.castShadow = true;
            group.add(armLeft);
            
            const armRight = new THREE.Mesh(armGeo, baseMat);
            armRight.position.set(0.8, 0.45, 0);
            armRight.castShadow = true;
            group.add(armRight);
            
            return group;
        }
        
        // Create desk with computer
        function createDesk() {
            const group = new THREE.Group();
            
            // Desk top
            const topGeo = new THREE.BoxGeometry(1.5, 0.05, 0.8);
            const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const top = new THREE.Mesh(topGeo, woodMat);
            top.position.y = 0.75;
            top.castShadow = true;
            top.receiveShadow = true;
            group.add(top);
            
            // Legs
            const legGeo = new THREE.BoxGeometry(0.05, 0.75, 0.05);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x2d3748 });
            const positions = [
                [-0.7, 0.375, -0.35],
                [0.7, 0.375, -0.35],
                [-0.7, 0.375, 0.35],
                [0.7, 0.375, 0.35]
            ];
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeo, legMat);
                leg.position.set(...pos);
                leg.castShadow = true;
                group.add(leg);
            });
            
            // Monitor
            const monitorGeo = new THREE.BoxGeometry(0.4, 0.3, 0.02);
            const monitorMat = new THREE.MeshStandardMaterial({ color: 0x1a202c });
            const monitor = new THREE.Mesh(monitorGeo, monitorMat);
            monitor.position.set(0, 0.9, -0.2);
            monitor.castShadow = true;
            group.add(monitor);
            
            // Screen glow
            const screenGeo = new THREE.PlaneGeometry(0.36, 0.26);
            const screenMat = new THREE.MeshBasicMaterial({ 
                color: 0x00d4ff,
                emissive: 0x00d4ff,
                emissiveIntensity: 0.5
            });
            const screen = new THREE.Mesh(screenGeo, screenMat);
            screen.position.set(0, 0.9, -0.19);
            group.add(screen);
            
            // Chair
            const chair = createChair();
            chair.position.set(0, 0, 0.8);
            chair.rotation.y = Math.PI;
            group.add(chair);
            
            return group;
        }
        
        // Create chair
        function createChair() {
            const group = new THREE.Group();
            
            // Seat
            const seatGeo = new THREE.BoxGeometry(0.5, 0.05, 0.5);
            const seatMat = new THREE.MeshStandardMaterial({ color: 0x2d3748 });
            const seat = new THREE.Mesh(seatGeo, seatMat);
            seat.position.y = 0.45;
            seat.castShadow = true;
            group.add(seat);
            
            // Back
            const backGeo = new THREE.BoxGeometry(0.5, 0.5, 0.05);
            const back = new THREE.Mesh(backGeo, seatMat);
            back.position.set(0, 0.7, -0.225);
            back.castShadow = true;
            group.add(back);
            
            // Base
            const baseGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.05, 16);
            const base = new THREE.Mesh(baseGeo, seatMat);
            base.position.y = 0.025;
            base.castShadow = true;
            group.add(base);
            
            // Stem
            const stemGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.45, 8);
            const stem = new THREE.Mesh(stemGeo, seatMat);
            stem.position.y = 0.225;
            group.add(stem);
            
            return group;
        }
        
        // Create coffee table
        function createCoffeeTable() {
            const group = new THREE.Group();
            
            // Top
            const topGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.05, 32);
            const topMat = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
            const top = new THREE.Mesh(topGeo, topMat);
            top.position.y = 0.4;
            top.castShadow = true;
            top.receiveShadow = true;
            group.add(top);
            
            // Legs
            const legGeo = new THREE.CylinderGeometry(0.03, 0.02, 0.4, 8);
            const legMat = new THREE.MeshStandardMaterial({ color: 0x2d3748 });
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2;
                const leg = new THREE.Mesh(legGeo, legMat);
                leg.position.set(Math.cos(angle) * 0.3, 0.2, Math.sin(angle) * 0.3);
                leg.castShadow = true;
                group.add(leg);
            }
            
            return group;
        }
        
        // Create plant
        function createPlant() {
            const group = new THREE.Group();
            
            // Pot
            const potGeo = new THREE.CylinderGeometry(0.25, 0.2, 0.4, 16);
            const potMat = new THREE.MeshStandardMaterial({ color: 0xc05621 });
            const pot = new THREE.Mesh(potGeo, potMat);
            pot.position.y = 0.2;
            pot.castShadow = true;
            group.add(pot);
            
            // Plant
            const plantGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const plantMat = new THREE.MeshStandardMaterial({ color: 0x48bb78 });
            const plant = new THREE.Mesh(plantGeo, plantMat);
            plant.position.y = 0.6;
            plant.castShadow = true;
            group.add(plant);
            
            return group;
        }
        
        // Create bookshelf
        function createBookshelf() {
            const group = new THREE.Group();
            
            // Frame
            const frameGeo = new THREE.BoxGeometry(1.2, 2, 0.3);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.y = 1;
            frame.castShadow = true;
            group.add(frame);
            
            // Shelves
            const shelfGeo = new THREE.BoxGeometry(1.1, 0.02, 0.28);
            for (let i = 1; i < 4; i++) {
                const shelf = new THREE.Mesh(shelfGeo, frameMat);
                shelf.position.y = i * 0.5;
                group.add(shelf);
                
                // Books
                for (let j = 0; j < 5; j++) {
                    const bookHeight = 0.15 + Math.random() * 0.1;
                    const bookWidth = 0.02 + Math.random() * 0.02;
                    const bookGeo = new THREE.BoxGeometry(bookWidth, bookHeight, 0.2);
                    const bookMat = new THREE.MeshStandardMaterial({ 
                        color: new THREE.Color().setHSL(Math.random(), 0.7, 0.5) 
                    });
                    const book = new THREE.Mesh(bookGeo, bookMat);
                    book.position.set(
                        -0.4 + j * 0.15 + Math.random() * 0.05,
                        i * 0.5 + bookHeight / 2,
                        0
                    );
                    book.castShadow = true;
                    group.add(book);
                }
            }
            
            return group;
        }

        // Initialize Three.js scene
        function initScene() {
            updateProgress(20);
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);
            
            // Fog for depth
            scene.fog = new THREE.Fog(0x0a0a0f, 5, 15);
            
            // Camera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 3.5);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1.5;
            controls.maxDistance = 8;
            controls.maxPolarAngle = Math.PI / 2 - 0.05;
            controls.target.set(0, 1.0, 0);
            
            // Enhanced Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 10, 7);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.1;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -10;
            mainLight.shadow.camera.right = 10;
            mainLight.shadow.camera.top = 10;
            mainLight.shadow.camera.bottom = -10;
            scene.add(mainLight);
            
            const rimLight = new THREE.DirectionalLight(0x00d4ff, 0.4);
            rimLight.position.set(-5, 5, -5);
            scene.add(rimLight);
            
            const fillLight = new THREE.DirectionalLight(0xff6b9d, 0.2);
            fillLight.position.set(-5, 0, 5);
            scene.add(fillLight);
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a2e,
                roughness: 0.8,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Grid pattern on floor
            const gridHelper = new THREE.GridHelper(20, 40, 0x00d4ff, 0x2d3748);
            gridHelper.position.y = 0.01;
            gridHelper.material.opacity = 0.15;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            // Walls
            createWalls();
            
            // Create furniture
            furniture = createFurniture();
            
            updateProgress(40);
            
            return { scene, camera, renderer, controls };
        }
        
        // Create office walls
        function createWalls() {
            const wallMat = new THREE.MeshStandardMaterial({ 
                color: 0x2d3748,
                roughness: 0.9
            });
            
            // Back wall
            const backWallGeo = new THREE.BoxGeometry(10, 4, 0.2);
            const backWall = new THREE.Mesh(backWallGeo, wallMat);
            backWall.position.set(0, 2, -4);
            backWall.receiveShadow = true;
            backWall.castShadow = true;
            scene.add(backWall);
            
            // Side wall
            const sideWallGeo = new THREE.BoxGeometry(0.2, 4, 10);
            const sideWall = new THREE.Mesh(sideWallGeo, wallMat);
            sideWall.position.set(-4, 2, 0);
            sideWall.receiveShadow = true;
            sideWall.castShadow = true;
            scene.add(sideWall);
            
            // Window on back wall
            const windowFrameGeo = new THREE.BoxGeometry(2, 1.5, 0.1);
            const windowFrameMat = new THREE.MeshStandardMaterial({ color: 0x1a202c });
            const windowFrame = new THREE.Mesh(windowFrameGeo, windowFrameMat);
            windowFrame.position.set(2, 2.5, -3.9);
            scene.add(windowFrame);
            
            // Window glass
            const glassGeo = new THREE.PlaneGeometry(1.8, 1.3);
            const glassMat = new THREE.MeshBasicMaterial({ 
                color: 0x87ceeb,
                transparent: true,
                opacity: 0.3,
                emissive: 0x87ceeb,
                emissiveIntensity: 0.2
            });
            const glass = new THREE.Mesh(glassGeo, glassMat);
            glass.position.set(2, 2.5, -3.85);
            scene.add(glass);
        }

        // Load VRM with CORS proxy fallback
        async function loadVRM() {
            updateProgress(50);
            
            const loader = new GLTFLoader();
            loader.register((parser) => new VRMLoaderPlugin(parser));
            
            // Try loading with different CORS proxies
            for (let i = 0; i < CORS_PROXIES.length; i++) {
                const proxyUrl = CORS_PROXIES[i] + encodeURIComponent(VRM_URL);
                
                try {
                    updateProgress(60 + (i * 10));
                    
                    const gltf = await new Promise((resolve, reject) => {
                        loader.load(
                            proxyUrl,
                            (gltf) => resolve(gltf),
                            (progress) => {
                                if (progress.total > 0) {
                                    const percent = (progress.loaded / progress.total) * 100;
                                    updateProgress(60 + (percent * 0.3));
                                }
                            },
                            (error) => reject(error)
                        );
                    });
                    
                    updateProgress(95);
                    
                    vrm = gltf.userData.vrm;
                    
                    // Configure VRM
                    VRMUtils.removeUnnecessaryVertices(gltf.scene);
                    VRMUtils.combineSkeletons(gltf.scene);
                    
                    // Add to scene
                    scene.add(vrm.scene);
                    
                    // Position VRM
                    vrm.scene.position.set(0, 0, 0);
                    vrm.scene.rotation.y = 0;
                    
                    // Enable shadows
                    vrm.scene.traverse((obj) => {
                        if (obj.isMesh) {
                            obj.castShadow = true;
                            obj.receiveShadow = true;
                        }
                    });
                    
                    // Set up animation mixer
                    if (vrm.expressionManager) {
                        mixer = vrm.expressionManager;
                    }
                    
                    updateProgress(100);
                    
                    // Hide loading screen
                    setTimeout(() => {
                        loadingScreen.classList.add('hidden');
                    }, 500);
                    
                    return vrm;
                    
                } catch (error) {
                    console.warn(`Proxy ${i + 1} failed:`, error.message);
                    if (i === CORS_PROXIES.length - 1) {
                        throw new Error('All CORS proxies failed. The VRM file may be unavailable or blocked.');
                    }
                }
            }
        }

        // AI Character Controller
        function updateAICharacter(delta) {
            if (!vrm || !isAIMode) return;
            
            const position = vrm.scene.position;
            const rotation = vrm.scene.rotation;
            
            switch (characterState) {
                case 'idle':
                    // Randomly choose next action
                    animationTimer -= delta;
                    if (animationTimer <= 0) {
                        chooseNextAction();
                    }
                    // Subtle idle animation
                    if (vrm.humanoid) {
                        const breathing = Math.sin(Date.now() * 0.002) * 0.02;
                        vrm.humanoid.getNormalizedBoneNode('chest').rotation.x = breathing;
                    }
                    break;
                    
                case 'walking':
                    if (targetPosition) {
                        const direction = new THREE.Vector3().subVectors(targetPosition, position);
                        const distance = direction.length();
                        
                        if (distance < 0.1) {
                            // Reached destination
                            characterState = 'interacting';
                            animationTimer = currentFurniture ? currentFurniture.interactTime / 1000 : 2;
                            // Sit down if furniture supports it
                            if (currentFurniture && currentFurniture.type === 'sofa') {
                                sitOnSofa();
                            } else if (currentFurniture && currentFurniture.type === 'computer') {
                                useComputer();
                            }
                        } else {
                            // Move towards target
                            direction.normalize();
                            position.add(direction.multiplyScalar(walkSpeed * delta));
                            
                            // Smooth rotation towards target
                            const targetRotation = Math.atan2(direction.x, direction.z);
                            const rotationDiff = targetRotation - rotation.y;
                            rotation.y += rotationDiff * rotationSpeed * delta;
                            
                            // Walking animation
                            playWalkAnimation(delta);
                        }
                    }
                    break;
                    
                case 'interacting':
                    animationTimer -= delta;
                    if (animationTimer <= 0) {
                        standUp();
                        characterState = 'idle';
                        animationTimer = 1 + Math.random() * 2;
                        currentFurniture = null;
                    } else {
                        playInteractAnimation(delta);
                    }
                    break;
            }
            
            // Update camera to follow character
            updateCameraFollow();
        }
        
        // Choose next AI action
        function chooseNextAction() {
            const rand = Math.random();
            
            if (rand < 0.7 && furniture.length > 0) {
                // Walk to furniture
                currentFurniture = furniture[Math.floor(Math.random() * furniture.length)];
                targetPosition = currentFurniture.sitPosition.clone();
                characterState = 'walking';
            } else {
                // Walk to random point
                targetPosition = new THREE.Vector3(
                    (Math.random() - 0.5) * 6,
                    0,
                    (Math.random() - 0.5) * 6
                );
                characterState = 'walking';
            }
        }
        
        // Walk animation
        function playWalkAnimation(delta) {
            if (!vrm || !vrm.humanoid) return;
            
            const time = Date.now() * 0.005;
            const walkCycle = Math.sin(time) * 0.3;
            
            // Legs
            vrm.humanoid.getNormalizedBoneNode('leftUpperLeg').rotation.x = walkCycle;
            vrm.humanoid.getNormalizedBoneNode('rightUpperLeg').rotation.x = -walkCycle;
            vrm.humanoid.getNormalizedBoneNode('leftLowerLeg').rotation.x = Math.abs(walkCycle) * 0.5;
            vrm.humanoid.getNormalizedBoneNode('rightLowerLeg').rotation.x = Math.abs(-walkCycle) * 0.5;
            
            // Arms
            vrm.humanoid.getNormalizedBoneNode('leftUpperArm').rotation.x = -walkCycle * 0.5;
            vrm.humanoid.getNormalizedBoneNode('rightUpperArm').rotation.x = walkCycle * 0.5;
            
            // Bobbing
            vrm.scene.position.y = Math.abs(Math.sin(time * 2)) * 0.03;
        }
        
        // Sit on sofa animation
        function sitOnSofa() {
            if (!vrm || !vrm.humanoid) return;
            
            // Lower position
            vrm.scene.position.y = 0.4;
            
            // Sit pose
            vrm.humanoid.getNormalizedBoneNode('leftUpperLeg').rotation.x = -Math.PI / 2;
            vrm.humanoid.getNormalizedBoneNode('rightUpperLeg').rotation.x = -Math.PI / 2;
            vrm.humanoid.getNormalizedBoneNode('leftLowerLeg').rotation.x = Math.PI / 2;
            vrm.humanoid.getNormalizedBoneNode('rightLowerLeg').rotation.x = Math.PI / 2;
            vrm.humanoid.getNormalizedBoneNode('spine').rotation.x = 0.2;
            
            // Relaxed arms
            vrm.humanoid.getNormalizedBoneNode('leftUpperArm').rotation.z = 0.2;
            vrm.humanoid.getNormalizedBoneNode('rightUpperArm').rotation.z = -0.2;
        }
        
        // Use computer animation
        function useComputer() {
            if (!vrm || !vrm.humanoid) return;
            
            vrm.scene.position.y = 0.5;
            
            // Sit pose
            vrm.humanoid.getNormalizedBoneNode('leftUpperLeg').rotation.x = -Math.PI / 2.5;
            vrm.humanoid.getNormalizedBoneNode('rightUpperLeg').rotation.x = -Math.PI / 2.5;
            vrm.humanoid.getNormalizedBoneNode('leftLowerLeg').rotation.x = Math.PI / 2.5;
            vrm.humanoid.getNormalizedBoneNode('rightLowerLeg').rotation.x = Math.PI / 2.5;
            
            // Arms forward (typing)
            vrm.humanoid.getNormalizedBoneNode('leftUpperArm').rotation.x = -0.8;
            vrm.humanoid.getNormalizedBoneNode('rightUpperArm').rotation.x = -0.8;
            vrm.humanoid.getNormalizedBoneNode('leftLowerArm').rotation.x = -0.5;
            vrm.humanoid.getNormalizedBoneNode('rightLowerArm').rotation.x = -0.5;
            
            // Look at screen
            vrm.humanoid.getNormalizedBoneNode('neck').rotation.x = 0.3;
        }
        
        // Stand up
        function standUp() {
            if (!vrm || !vrm.humanoid) return;
            
            vrm.scene.position.y = 0;
            
            // Reset pose
            const bones = ['leftUpperLeg', 'rightUpperLeg', 'leftLowerLeg', 'rightLowerLeg', 
                          'leftUpperArm', 'rightUpperArm', 'leftLowerArm', 'rightLowerArm',
                          'spine', 'neck'];
            bones.forEach(boneName => {
                const bone = vrm.humanoid.getNormalizedBoneNode(boneName);
                if (bone) bone.rotation.set(0, 0, 0);
            });
        }
        
        // Interaction animation (typing, looking around, etc)
        function playInteractAnimation(delta) {
            if (!vrm || !vrm.humanoid) return;
            
            const time = Date.now() * 0.001;
            
            if (currentFurniture && currentFurniture.type === 'computer') {
                // Typing animation
                const typing = Math.sin(time * 15) * 0.1;
                vrm.humanoid.getNormalizedBoneNode('leftLowerArm').rotation.x = -0.5 + typing;
                vrm.humanoid.getNormalizedBoneNode('rightLowerArm').rotation.x = -0.5 - typing;
            } else {
                // Relaxed idle
                const sway = Math.sin(time * 0.5) * 0.05;
                vrm.humanoid.getNormalizedBoneNode('spine').rotation.z = sway;
                
                // Look around occasionally
                if (Math.random() < 0.01) {
                    vrm.humanoid.getNormalizedBoneNode('neck').rotation.y = (Math.random() - 0.5) * 0.5;
                }
            }
        }
        
        // Update camera to follow character
        function updateCameraFollow() {
            if (!vrm || !isAIMode) return;
            
            const characterPos = vrm.scene.position.clone();
            
            // Smooth camera follow
            const targetPos = characterPos.clone().add(cameraOffset);
            camera.position.lerp(targetPos, 0.05);
            
            // Look at character
            cameraTarget.lerp(characterPos.clone().add(new THREE.Vector3(0, 1, 0)), 0.1);
            camera.lookAt(cameraTarget);
        }

        // Toggle fullscreen mode
        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            
            if (isFullscreen) {
                // Hide UI
                uiOverlay.classList.add('hidden');
                fullscreenBtn.classList.add('hidden');
                exitHint.classList.add('visible');
                aiStatus.classList.add('visible');
                
                // Enable AI mode
                isAIMode = true;
                characterState = 'idle';
                animationTimer = 1;
                
                // Request browser fullscreen
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                }
                
                // Disable orbit controls in AI mode
                controls.enabled = false;
            } else {
                // Show UI
                uiOverlay.classList.remove('hidden');
                fullscreenBtn.classList.remove('hidden');
                exitHint.classList.remove('visible');
                aiStatus.classList.remove('visible');
                
                // Disable AI mode
                isAIMode = false;
                characterState = 'idle';
                standUp();
                
                // Exit browser fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
                
                // Re-enable orbit controls
                controls.enabled = true;
                
                // Reset camera
                camera.position.set(0, 1.6, 3.5);
                controls.target.set(0, 1.0, 0);
                controls.update();
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // Update VRM
            if (vrm) {
                vrm.update(delta);
            }
            
            // Update AI character
            updateAICharacter(delta);
            
            // Update controls (only if enabled)
            if (controls.enabled) {
                controls.update();
            }
            
            // Render
            renderer.render(scene, camera);
        }

        // Main initialization
        async function init() {
            try {
                initScene();
                await loadVRM();
                
                // Start animation loop
                animate();
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // Reset view button
                document.getElementById('resetBtn').addEventListener('click', () => {
                    camera.position.set(0, 1.6, 3.5);
                    controls.target.set(0, 1.0, 0);
                    controls.update();
                });
                
                // Animation toggle
                let animating = false;
                document.getElementById('animBtn').addEventListener('click', () => {
                    animating = !animating;
                    if (vrm && vrm.expressionManager) {
                        if (animating) {
                            vrm.expressionManager.setValue('happy', 0.5);
                        } else {
                            vrm.expressionManager.setValue('happy', 0);
                        }
                    }
                });
                
                // Fullscreen button
                fullscreenBtn.addEventListener('click', toggleFullscreen);
                
                // ESC key to exit fullscreen
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && isFullscreen) {
                        toggleFullscreen();
                    }
                });
                
                // Handle browser fullscreen change
                document.addEventListener('fullscreenchange', () => {
                    if (!document.fullscreenElement && isFullscreen) {
                        toggleFullscreen();
                    }
                });
                
            } catch (error) {
                console.error('Failed to initialize VRM viewer:', error);
                showError(error.message || 'An unexpected error occurred while loading the VRM.');
            }
        }

        // Start immediately when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
